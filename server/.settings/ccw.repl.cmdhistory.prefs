cmdhistory=["test" "amap" ";; Switching to server.core namespace" "(defn -main\\n  \\"I don't do a whole lot ... yet.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))" "(-main)" "\#{{\:figure \:pawn \:loc [0 3]}}" "\#{{\:figure \:pawn \:loc [0 3]} {\:figure \:pawn \:loc [0 3]}}" "\#{{\:figure \:pawn \:loc [0 3]} {\:figure \:pawn \:loc [0 2]}}" "(-main)" ";; Switching to server.core namespace" "(-main)" ";; Switching to server.game namespace" "(generate-string {\:foo \\"bar\\" \:baz 5})" "(generate-string {\:type \\"move\\" \:content {\:from \\"a6\\" \:to \\"g7\\"}})" "(parse-string \\"{\\\\\\"content\\\\\\"\:{\\\\\\"from\\\\\\"\:\\\\\\"a6\\\\\\",\\\\\\"to\\\\\\"\:\\\\\\"g7\\\\\\"},\\\\\\"type\\\\\\"\:\\\\\\"move\\\\\\"}\\")" "(parse-string \\"{\\\\\\"content\\\\\\"\:{\\\\\\"from\\\\\\"\:\\\\\\"a6\\\\\\",\\\\\\"to\\\\\\"\:\\\\\\"g7\\\\\\"},\\\\\\"type\\\\\\"\:\\\\\\"move\\\\\\"}\\" true)" "(clojure.set/union \#{1 2} \#{3 4})" ";; Switching to server.game namespace" "(clojuer.set\\\\union \#{1 2} \#{3})" "(clojure.set/union \#{1 2} \#{3 4})" "(concat [\#{1 2} \#{3}] [\#{4 3}])" "(apply clojure.set/union (concat [\#{1 2} \#{3}] [\#{4 3}]))" ";; Switching to server.game namespace" "(set/union \#{1} \#{2})" "(parse-string {\:a 1})" "(generate-string {\:a 1})" "(condp identical? \:foo\\n  \:bar \\"bar\\"\\n  \:foo \\"foo\\")" ";; Switching to server.game namespace" "(to-chess-position 1)" "(defn to-chess-position [indexed-cell]\\r\\n  (format \\"%c%d\\" \\r\\n          (+ (first indexed-cell) 97) \\r\\n          (second indexed-cell)))" "(to-chess-position [1 5])" "(defn to-chess-position [indexed-cell]\\r\\n  (format \\"%c%d\\" \\r\\n          (-> (first indexed-cell) (+ 97) char) \\r\\n          (second indexed-cell)))" "(to-chess-position [1 5])" "(defn to-chess-position [indexed-cell]\\r\\n  (format \\"%c%d\\" \\r\\n          (-> (first indexed-cell) (+ 97) char) \\r\\n          (-> (second indexed-cell) (+ 1)))" "(defn to-chess-position [indexed-cell]\\r\\n  (format \\"%c%d\\" \\r\\n          (-> (first indexed-cell) (+ 97) char) \\r\\n          (-> (second indexed-cell) (+ 1))))" "(to-chess-position [1 5])" ";; Switching to server.game namespace" "(gen" "(generate-init-message nil)" "(use 'server.game)" "(generate-init-message (ref {\:pieces {\:pawn \#{[1 2] [3 4]} \:knight \#{[4 4] [5 6]}}}))" "(defn foo [a] (when-not (idencial? a \:foo) \:sad))" "(defn foo [a] (when-not (identical? a \:foo) \:sad))" "(foo \:foo)" "(- [3 3] [2 2])" "(disj \#{1 2 3} 1)" "(disj \#{1 2 3} 5\\n      )" ";; Switching to server.game namespace" "(def p \:foo)" "(\= \:foo p)" "(defn foo [] (\\"1\\" (when-let (\= 1 2) \\"2\\")))" "(defn foo [] (\\"1\\" (when (\= 1 2) \\"2\\")))" "(foo)" "(defn foo [] ([1 2] (when (\= 1 2) \\"2\\")))" "(foo)" "(defn foo [a] ([1 2] (when (\= 1 2) \\"2\\")))" "(foo 1)" "(defn foo [a] (a (when (\= 1 2) \\"2\\")))" "(foo)" "(defn foo [a] ((+ a 1) (when (\= 1 2) \\"2\\")))" "(foo 2)" "(defn foo [a] \\n  (let [res (+ a 1)]\\n    res\\n    (when (\= 1 2) \\"foo\\")))" "(foo 2)" "(defn foo [a] \\n  (let [res (+ a 1)]\\n    res\\n    (when (\= 1 1) \\"foo\\")))" "(foo 4)" "(- 2 -3)" "(def p nil)" "(\= nil p)" ";; Switching to server.game namespace" "((complement nil?) 12)" "(some \#{1 2} [1 2])" "(not 1)" "(some \#{1 2} [12\\n              ])" "(not nil)" ";; Switching to server.game namespace" "(range 1 1)" "(range 1 3)" "(clean-diagonal-path? [[1 2] [3 4] \#{}])" "(clean-diagonal-path? [1 2] [3 4] \#{})" "(clean-diagonal-path? [0 1] [4 5] \#{})" "(clean-diagonal-path? [0 1] [4 5] \#{[3 4]})" "(clean-diagonal-path? [0 1] [4 5] \#{[2 3]})" "(clean-diagonal-path? [0 1] [4 5] \#{[4 5]})" "(clean-diagonal-path? [4 5] [0 1] \#{[4 5]})" "(clean-diagonal-path? [4 5] [0 1] \#{[3 4]})" "(clean-diagonal-path? [6 0] [2 6] \#{[3 4]})" "(clean-diagonal-path? [6 0] [2 6] \#{[3 3]})" "(clean-diagonal-path? [6 0] [2 5] \#{[3 3]})" "(clean-diagonal-path? [7 0] [2 5] \#{[3 3]})" "(clean-diagonal-path? [7 0] [2 5] \#{[3 3] [5 2]})" "(with-higher-file? [7 0] [3 4])" "(with-higher-rank? [7 0] [2 5])" "(clean-diagonal-path? [7 0] [2 5] \#{[3 3] [5 2]})" "(clean-diagonal-path? [7 0] [2 5] \#{[3 3] [5 3]})" "(clean-vertical-path? [0 4] [0 6] \#{})" "(clean-vertical-path? [0 4] [0 6] \#{3 4})" "(clean-horizontal-path? [0 4] [5 6] \#{3 4})" "(clean-horizontal-path? [0 4] [5 4] \#{3 4})" "(clean-horizontal-path? [0 4] [5 4] \#{[3 4]})" "(clean-vertical-path? [3 7] [3 2] \#{[3 4]})" "(clean-vertical-path? [3 7] [3 2] \#{[4 4]})" "(defmethod make-move \:pawn\\n  [piece from to piece-owner opponent]\\n  (let [[from-f from-r] from\\n        [to-f to-r] to\\n        color (\:pieces-color @piece-owner)\\n        coef (if (\= \:black color) 1 -1)\\n        rank-diff (-> (- from-r to-r) (* coef))]\\n    (condp \= rank-diff\\n      1 \\n      (let [p (move-piece piece from to piece-owner opponent)]\\n        (cond\\n          ;; Slightly possible but if pawn takes the king we don't care for promotion.\\n          (\= \:king p) \\n          p\\n          ;; Check for pawn promotion.\\n          (pawn-promotion-square? to color) \\n          (do \\n            (promote-pawn to piece-owner) \:promotion)\\n          ;; Pawn did take opponent's piece.\\n          ((complement nil?) p) \\n          p\\n          ;; Pawn moved to vacant square so check for 'en-passant'\\n          \:else\\n          (let [passant-square [to-f (+ to-r coef)]\\n                p (piece-at-square passant-square opponent)]\\n            (if (\= \:pawn p)\\n              (dosync\\n                (alter opponent update-in [\:pieces \:pawn] disj passant-square))\\n              nil))))\\n      2 \\n      (if \\n        (and (pawn-start-square? from color)\\n              (clean-vertical-path? from \\n                                    to \\n                                    (find-piece-squares piece-owner opponent))\\n        (move-piece piece from to piece-owner opponent)\\n        \:invalid)))))" "(empty? {})" "(empty? {\:a 1\\n         })" "(possible-pawn-squares [0 3] \:white)" "(possible-pawn-squares [0 1] \:white)" "(pawn-start-square? [0 1] \:white)" "(possible-pawn-squares [0 1] \:white)" "(identical? nil [1 2])" "(identical? [1 2] [1 2])" "(\= [1 2] [1 2])" "(possible-pawn-squares [0 1] \:white)" " (peek [1 2 3 4])" "(not \#{1 2})" "(not nil)" ";; Switching to server.game namespace" "(ns server.game)" "(not (some [] \#{12 13})" "(not (some [] \#{12 13}))" "(not (some '() \#{12 13}))" "(not (some \#{} \#{12 13}))" "(clean-horizontal-path? [0 1] [1 2] \#{1 1})" "(clean-horizontal-path? [0 1] [1 2] \#{[1 1]})" "(clean-horizontal-path? [0 1] [1 1] \#{[1 1]})" ";; Switching to server.game namespace" "(defn foo [[x y \:as coord]] ((+ x y)))" "(defn foo [[x y \:as coord]] \\n  (println coord)\\n  (+ x y))" "(foo [1 2])" "(defn foo [a [x y \:as coord] b] \\n  (println coord)\\n  (+ x y))" "(foo 1 [1 2] 3)" "(key {\:foo \\"pupata\\"})" "(first {\:foo \\"pupata\\"})" "(some \#{1 2} [4 5 6 7])" "(seq {\:1 a})" "(seq {\:1 2})" "(every? \#{1 2} [1 2])" "(every? \#{1 2} [1 2 3])"]
eclipse.preferences.version=1
